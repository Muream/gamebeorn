package memory

import "core:fmt"
import "core:log"


Memory :: struct {
    mem: []u8,
}

// odinfmt: disable
NINTENDO_LOGO := [?]u8{
    0xCE, 0xED, 0x66, 0x66, 0xCC, 0x0D, 0x00, 0x0B, 0x03, 0x73, 0x00, 0x83, 0x00, 0x0C, 0x00, 0x0D,
    0x00, 0x08, 0x11, 0x1F, 0x88, 0x89, 0x00, 0x0E, 0xDC, 0xCC, 0x6E, 0xE6, 0xDD, 0xDD, 0xD9, 0x99,
    0xBB, 0xBB, 0x67, 0x63, 0x6E, 0x0E, 0xEC, 0xCC, 0xDD, 0xDC, 0x99, 0x9F, 0xBB, 0xB9, 0x33, 0x3E,
}
// odinfmt: enable

init :: proc() -> Memory {
    log.debug("Init Memory")
    mem := make([]u8, 64 * 1024)
    copy(mem[0x8000:], NINTENDO_LOGO[:])
    // AF=$01B0
    //   BC=$0013
    //   DE=$00D8
    //   HL=$014D
    //   Stack Pointer=$FFFE
    mem[0xFF05] = 0x00 // TIMA
    mem[0xFF06] = 0x00 // TMA
    mem[0xFF07] = 0x00 // TAC
    mem[0xFF10] = 0x80 // NR10
    mem[0xFF11] = 0xBF // NR11
    mem[0xFF12] = 0xF3 // NR12
    mem[0xFF14] = 0xBF // NR14
    mem[0xFF16] = 0x3F // NR21
    mem[0xFF17] = 0x00 // NR22
    mem[0xFF19] = 0xBF // NR24
    mem[0xFF1A] = 0x7F // NR30
    mem[0xFF1B] = 0xFF // NR31
    mem[0xFF1C] = 0x9F // NR32
    mem[0xFF1E] = 0xBF // NR33
    mem[0xFF20] = 0xFF // NR41
    mem[0xFF21] = 0x00 // NR42
    mem[0xFF22] = 0x00 // NR43
    mem[0xFF23] = 0xBF // NR30
    mem[0xFF24] = 0x77 // NR50
    mem[0xFF25] = 0xF3 // NR51
    mem[0xFF26] = 0xF1 // NR52
    mem[0xFF40] = 0x91 // LCDC
    mem[0xFF42] = 0x00 // SCY
    mem[0xFF43] = 0x00 // SCX
    mem[0xFF45] = 0x00 // LYC
    mem[0xFF47] = 0xFC // BGP
    mem[0xFF48] = 0xFF // OBP0
    mem[0xFF49] = 0xFF // OBP1
    mem[0xFF4A] = 0x00 // WY
    mem[0xFF4B] = 0x00 // WX
    mem[0xFFFF] = 0x00 // IE
    return {mem}
}

read :: proc(self: ^Memory, address: u16) -> u8 {
    if cast(uint)address >= len(self.mem) {
        fmt.panicf("Invalid write @ %X", address)
    }
    return self.mem[address]
}

write :: proc(self: ^Memory, address: u16, value: u8) {

    if cast(uint)address >= len(self.mem) {
        fmt.panicf("Invalid write @ %X", address)
    }

    self.mem[address] = value

}
